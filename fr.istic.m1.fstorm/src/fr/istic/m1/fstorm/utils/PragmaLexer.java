package fr.istic.m1.fstorm.utils;

import java.util.ArrayList;
import java.util.List;

import fr.istic.m1.fstorm.PragmaLexicalUnit;
import fr.istic.m1.fstorm.beans.PragmaIdentifier;
import fr.istic.m1.fstorm.beans.PragmaSymbol;

/**
 * Lexical analyzer for fstorm pragmas.
 * @author KÃ©vin Le Bon
 *
 */
public class PragmaLexer {
	/**
	 * Helper function generating a new identifier object.
	 * @see PragmaIdentifier
	 * @param id the identifier.
	 * @return the newly generated identifier object.
	 */
	protected static PragmaLexicalUnit createIdentifier(String id) {
		return new PragmaIdentifier(id);
	}
	
	/**
	 * Helper function generating a new symbol object.
	 * @see PragmaSymbol
	 * @param sym the symbol.
	 * @return the newly generated symbol object.
	 */
	protected static PragmaLexicalUnit createSymbol(String sym) {
		return new PragmaSymbol(sym);
	}
	
	/**
	 * Function generating a list of tokens from the pragma given as argument.
	 * @param pragma Pragma on which the lexical analysis is done.
	 * @return the token list generated by the lexical analysis of the pragma.
	 * @throws PragmaLexicalException
	 */
	public static List<PragmaLexicalUnit> generateTokenList(String pragma) throws PragmaLexicalException {
		List<PragmaLexicalUnit> tokenList = new ArrayList<PragmaLexicalUnit>();
		
		for(int cursor = 0; cursor < pragma.length(); ++cursor) {
			if(isBlank(pragma.charAt(cursor))) {
				continue;
			}
			
			else if(Character.isAlphabetic(pragma.charAt(cursor))
					|| pragma.charAt(cursor) == '_') {
				String ident = "" + pragma.charAt(cursor);
				cursor++;
				while(cursor < pragma.length() && isValidIdentifierCharacter(pragma.charAt(cursor))) {
					ident += pragma.charAt(cursor);
					cursor++;
				}
				
				tokenList.add(createIdentifier(ident));
				cursor--;
				
			}
			
			else if(isValidSymbol(pragma.charAt(cursor))) {
				String sym = "" + pragma.charAt(cursor);
				cursor++;
				
				tokenList.add(createSymbol(sym));
				cursor--;
			}
			
			else
				throw new PragmaLexicalException("" + cursor);
		}
		
		return tokenList;
	}

	/**
	 * Function checking whether the given character can be used in a Java identifier.
	 * @param ch the character to check.
	 * @return true if it can be used in a Java identifier, false otherwise.
	 */
	private static boolean isValidIdentifierCharacter(char ch) {
		return Character.isAlphabetic(ch)
				|| Character.isDigit(ch)
				|| ch == '_';
	}

	/**
	 * Function checking whether the given character is a valid symbol to be used by fstorm preprocessor.
	 * @param ch the character to check.
	 * @return true if the given character is a valid fstorm preprocessor symbol, false otherwise.
	 */
	private static boolean isValidSymbol(char ch) {
		return "<>()[].,".indexOf(ch) != -1;
	}

	/**
	 * Function checking whether the given character is a blank.
	 * @param ch the character to check.
	 * @return true if the character is a blank, false otherwise.
	 */
	private static boolean isBlank(char ch) {
		return " \t".indexOf(ch) != -1;
	}
}
